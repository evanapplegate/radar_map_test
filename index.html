<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radar Floating - Mapbox + Three.js</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.css' rel='stylesheet' />
    <script src="https://unpkg.com/three@0.126.0/build/three.min.js"></script>
    <style>
        body { margin: 0; padding: 0; }
        #map { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="map"></div>
    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoiZXZhbmRhcHBsZWdhdGUiLCJhIjoiY2tmbzA1cWM1MWozeTM4cXV4eHUwMzFhdiJ9.Z5f9p8jJD_N1MQwycF2NEw';

        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/satellite-streets-v12',
            projection: 'globe',
            center: [-98, 39], // US Center
            zoom: 4,
            pitch: 60
        });

        map.on('load', () => {
            map.addSource('mapbox-dem', {
                'type': 'raster-dem',
                'url': 'mapbox://mapbox.terrain-rgb',
                'tileSize': 512,
                'maxzoom': 14
            });
            map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });

            // 1. SHADOW LAYER (Ground)
            // Standard raster layer, blackened to look like a shadow
            map.addSource('radar-source', {
                'type': 'raster',
                'tiles': [
                    'https://mesonet.agron.iastate.edu/cache/tile.py/1.0.0/nexrad-n0q-900913/{z}/{x}/{y}.png'
                ],
                'tileSize': 256
            });

            map.addLayer({
                'id': 'radar-shadow',
                'type': 'raster',
                'source': 'radar-source',
                'paint': {
                    'raster-opacity': 0.5,
                    'raster-brightness-max': 0, // Force black
                    'raster-saturation': -1
                }
            });

            // 2. FLOATING LAYER (Three.js)
            const customLayer = {
                id: 'radar-3d',
                type: 'custom',
                renderingMode: '3d',
                onAdd: function(map, gl) {
                    this.camera = new THREE.Camera();
                    this.scene = new THREE.Scene();

                    // Add lights so we can see things if we use standard materials
                    const light = new THREE.DirectionalLight(0xffffff, 1);
                    light.position.set(0, 0, 1);
                    this.scene.add(light);
                    this.scene.add(new THREE.AmbientLight(0xffffff, 0.5));

                    // Helper to load a tile and place it at altitude
                    const loadTilePlane = (z, x, y) => {
                        const url = `https://mesonet.agron.iastate.edu/cache/tile.py/1.0.0/nexrad-n0q-900913/${z}/${x}/${y}.png`;
                        const loader = new THREE.TextureLoader();
                        
                        loader.load(url, (texture) => {
                            // Calculate bounds in Lat/Lon
                            const n = Math.pow(2, z);
                            const lon1 = x / n * 360 - 180;
                            const lon2 = (x + 1) / n * 360 - 180;
                            const latRad1 = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)));
                            const latRad2 = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n)));
                            const lat1 = latRad1 * 180 / Math.PI;
                            const lat2 = latRad2 * 180 / Math.PI;

                            // Altitude in meters
                            const altitude = 100000; // 100km up for dramatic effect

                            // Calculate Mercator Coordinates for the corners at altitude
                            const c1 = mapboxgl.MercatorCoordinate.fromLngLat([lon1, lat1], altitude);
                            const c2 = mapboxgl.MercatorCoordinate.fromLngLat([lon2, lat1], altitude);
                            const c3 = mapboxgl.MercatorCoordinate.fromLngLat([lon2, lat2], altitude);
                            const c4 = mapboxgl.MercatorCoordinate.fromLngLat([lon1, lat2], altitude);

                            // Create Geometry
                            const geometry = new THREE.BufferGeometry();
                            // Three.js uses counter-clockwise triangles
                            // 1---2
                            // | / |
                            // 4---3
                            const vertices = new Float32Array([
                                c1.x, c1.y, c1.z, // TL
                                c4.x, c4.y, c4.z, // BL
                                c2.x, c2.y, c2.z, // TR
                                
                                c4.x, c4.y, c4.z, // BL
                                c3.x, c3.y, c3.z, // BR
                                c2.x, c2.y, c2.z  // TR
                            ]);

                            // UVs (match the vertex order)
                            // TL(0,1) - note texture coordinates often y-flipped in webgl
                            // Let's try standard mapping: y=0 is bottom?
                            // Tile image: y=0 is top usually. 
                            // Mapbox tiles: top-left origin.
                            // Three.js UV: (0,0) is bottom-left.
                            // So TL is (0,1), BL is (0,0), TR is (1,1), BR is (1,0)
                            
                            const uvs = new Float32Array([
                                0, 1, // TL
                                0, 0, // BL
                                1, 1, // TR
                                
                                0, 0, // BL
                                1, 0, // BR
                                1, 1  // TR
                            ]);

                            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                            geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

                            const material = new THREE.MeshBasicMaterial({
                                map: texture,
                                transparent: true,
                                opacity: 0.9,
                                side: THREE.DoubleSide,
                                depthTest: false // Always on top of other things in this layer
                            });

                            const mesh = new THREE.Mesh(geometry, material);
                            this.scene.add(mesh);
                            map.triggerRepaint();
                        });
                    };

                    // Load a grid of tiles covering US roughly (Zoom 4)
                    // X: 3 to 4, Y: 5 to 6 covers a chunk
                    // US Zoom 4 roughly x=2..4, y=5..6
                    for (let x = 2; x <= 5; x++) {
                        for (let y = 5; y <= 7; y++) {
                            loadTilePlane(4, x, y);
                        }
                    }

                    this.map = map;
                    this.renderer = new THREE.WebGLRenderer({
                        canvas: map.getCanvas(),
                        context: gl,
                        antialias: true
                    });
                    this.renderer.autoClear = false;
                },
                render: function(gl, matrix) {
                    const m = new THREE.Matrix4().fromArray(matrix);
                    this.camera.projectionMatrix = m;
                    this.renderer.resetState();
                    this.renderer.render(this.scene, this.camera);
                    this.map.triggerRepaint();
                }
            };

            map.addLayer(customLayer);
        });
    </script>
</body>
</html>
